Playbooks
~~~~~~~~~~~

Playbooks Ansible предлагают воспроизводимую, многократно используемую, простую систему управления конфигурацией и развертывания на нескольких компьютерах, которая хорошо подходит для развертывания сложных приложений. 
Это файл, в котором описываются действия, которые нужно выполнить на какой-то группе хостов.
Если необходимо выполнить задачу с помощью Ansible более одного раза, создается playbook и помещается в систему управления версиями. 
Затем можно использовать плейбук для запуска новой конфигурации или подтверждения конфигурации удаленных систем. 

Для работы Playbooks необходимо:

* объявить конфигурации;
* организовать этапы любого процесса, упорядоченного вручную, на нескольких наборах машин в определенном порядке;
* запустить задачи синхронно или асинхронно

Синтаксис playbook:
"""""""""""""""""""""

Playbooks представлены в формате YAML с минимальным синтаксисом. 

Playbook состоит из одной или нескольких "play" в упорядоченном списке. 
Каждая play выполняет часть общей цели playbook, выполняя одну или несколько задач. Каждая задача вызывает модуль Ansible.

Выполнение Playbook
"""""""""""""""""""""""

Playbook выполняется по порядку сверху вниз. 
В каждом блоке задания также выполняются по порядку сверху вниз. 
Playbooks с несколькими "plays" могут организовывать развертывание на нескольких компьютерах, запуская один з игру на ваших веб-серверах, 
затем другую игру на серверах баз данных, затем третью игру в вашей сетевой инфраструктуре и так далее. 

Как минимум, каждый play определяет две вещи:

* управляемые узлы, для которых требуется выполнить работу, используя шаблон;
* как минимум одна задача для выполнения.

Пример:
''''''''

::

	- name: "First step"
	hosts: localhost
	tasks:
	- taskA
	- taskB

	- name: "Second step"
	hosts: all
	tasks:
	- taskC
	- taskD


Выполнение задачи (task)
"""""""""""""""""""""""

Как правило **task** - это всего-лишь модуль Ansible. То есть при вызове какой-либо **task**, на самом деле вызывается модуль Ansible с его параметрами. 
Поэтому богатство "языка" Ansible зависит от количества его модулей.
Записать task можно в двух видах: кратком, и полном. Вот пример команды установки переменной (set_fact) в кратком виде:

::

	- set_fact: mytext="Hello world"
	
	
Тогда play с этим task выглядит так:

::

	- name: "First step"
	  hosts: localhost
	  tasks:
	  - set_fact: mytext="Hello world"


По умолчанию Ansible выполняет каждую задачу по порядку, по одной за раз, на всех машинах, соответствующих шаблону хоста. 
Каждая задача выполняет модуль с определенными аргументами. Когда задача выполнена на всех целевых машинах, Ansible переходит к следующей задаче. 
В каждой play Ansible применяет одни и те же директивы задач ко всем хостам. 
Если на хосте происходит сбой задачи, Ansible выводит этот хост из ротации для остальной части сценария.


В данном скрипте установлена переменная **mytext**, равную “Hello world” для хоста localhost.

Следующей командой можно вывести на экран переменную, используя модуль (команду) debug:

::

	- name: "First step"
	  hosts: localhost
	  tasks:
	  - set_fact: mytext="Hello world"
	  - debug: var: mytext
  
  
Существует возможность более полно описать команду (task), дать ему имя (name). 
Совсем как в блоках задач (play). Тогда получившийся текст выглядит как подзадача нашего основного блока задач. 

::

	- name: "First step"
	  hosts: localhost
	  tasks:
	  - name: "Set variable"
		set_fact:
		  mytext="Hello world"
	  - name: "Show variable"
		debug:
		  var: mytext
		  
В этому случае сразу видно, что есть блок задач “First step“, в нем существует 2 подзадачи. 

Первая – с установкой переменной. 

Вторая – вызывает модуль debug с параметром var: и указанием имени переменной mytext.

**debug**

Модуль debug позволяет отображать информацию на стандартный поток вывода. Это может быть произвольная строка, переменная, факты об устройстве.

**Запуск**

Cохранить получившийся текст в файл "first.yml" и запустить его следующим образом:

ansible-playbook ./first.yml




1 play: цель - web server
2 play: цель - сервер баз данных

::

        ---
        - name: Update web servers
          hosts: webservers
          remote_user: root

          tasks:
          - name: Ensure apache is at the latest version
            ansible.builtin.yum:
              name: httpd
              state: latest
          - name: Write the apache config file
            ansible.builtin.template:
              src: /srv/httpd.j2
              dest: /etc/httpd.conf

        - name: Update db servers
          hosts: databases
          remote_user: root

          tasks:
          - name: Ensure postgresql is at the latest version
            ansible.builtin.yum:
              name: postgresql
              state: latest
          - name: Ensure that postgresql is started
            ansible.builtin.service:
              name: postgresql
              state: started



Когда запускается здфнищщл, Ansible возвращает информацию о подключениях, строках имен всех ваших plays и задач, о том, была ли каждая задача выполнена успешно или неудачно на каждой машине, и внесла ли каждая задача изменения на каждой машине. В нижней части выполнения playbook Ansible предоставляет сводную информацию о целевых узлах и о том, как они выполнялись. Общие сбои и фатальные попытки “недоступной” связи хранятся отдельно в графах.

Желаемое состояние и "идемпотентность"
""""""""""""""""""""""""""""""""""""""""""

Большинство модулей Ansible проверяют, достигнуто ли уже желаемое конечное состояние, и выходят без выполнения каких-либо действий, если это состояние достигнуто, чтобы повторение задачи не изменило конечное состояние. Модули, которые ведут себя таким образом, часто называют "идемпотентными". Независимо от того, запускаете ли вы playbook один раз или несколько раз, результат должен быть одинаковым. Однако не все ведут себя таким образом. Необходимо тестировать свои playbook в изолированной среде, прежде чем запускать их несколько раз в рабочей среде.

Запуск playbook
""""""""""""""""""""


