Задания для выполнения
~~~~~~~~~~~~~~~~~~~~~~~

Ограничение: Все задания надо выполнять используя только пройденные темы.

2.1. Напишите программу на Python, чтобы получить строку из заданной строки, 
в которой все вхождения ее первого символа были изменены на **'$'**, за исключением самого первого символа.

Пример строки : 'restart'

Ожидаемый результат : 'resta$t'

2.2. Напишите программу на Python, чтобы получить одну строку из двух заданных строк, 
разделенных пробелом, и поменять местами первые два символа в каждой строке.

Пример строки : 'abc', 'xyz'

Ожидаемый результат: 'xyc abz'

2.3. Напишите скрипт на Python, который принимает входные данные от пользователя и отображает их обратно в верхнем и нижнем регистрах.

Пример строки : english

Ожидаемый результат: ENGLISH english

2.4. Получить из строки travel такой **список** городов:

['Москва', 'Красноярск', 'Новосибирск', 'Челябинск', 'Магадан', 'Петропавловск-Камчатский', 'Курск']

Записать итоговый список в переменную **result**.

Полученный список **result** вывести на стандартный поток вывода (stdout) с помощью print. 

Ограничение: Все задания надо выполнять используя только пройденные темы.


.. code:: python

	travel = "Города посещения Москва, Красноярск, Новосибирск, Челябинск, Магадан, Петропавловск-Камчатский, Курск"
	
	
2.5. Получить из строк **travel_1**, **travel_1** итоговый список **result**, в котором отсутствуют дубликаты наименований городов :

['Москва', 'Красноярск', 'Новосибирск', 'Челябинск', 'Магадан', 'Петропавловск-Камчатский', 'Курск']

Записать итоговый список в переменную **result**.

Полученный список **result** вывести на стандартный поток вывода (stdout) с помощью print. 

.. code:: python

	travel_1 = "Города посещения Москва, Красноярск, Новосибирск, Челябинск, Магадан, Петропавловск-Камчатский, Курск"
	travel_2 = "Города посещения Москва, Санкт-Петербург, Челябинск, Златоуст, Уфа, Самара, Курск, Новосибирск"

2.6 Из строк travel_1  и travel_2  получить список городов, которые присутствуют в обоих турах (пересечение).

В данном случае, результатом должен быть такой список: ['Москва', 'Челябинск', 'Курск', 'Новосибирск']

Записать итоговый список в переменную **result**.

Полученный список result вывести на стандартный поток вывода (stdout) с помощью print.

2.7 Обработать строку **info** и вывести информацию на стандартный поток вывода в виде:

Город                           Красноярск
Год основания                   1628
Население                       1205473
Площадь (кв.км)                 413
Среднегодовая температура       +2.0

.. code:: python

	info = 'Красноя́рск 1628 1205473 413 +2.0' 



 





Множество − это совокупность объектов. Объекты, составляющие множество, называются его элементами.

Множество (**set**) в Python — это изменяемый набор уникальных и неупорядоченных элементов.

Основные свойства множеств:

- Уникальность: каждый элемент множества неповторим. Дубликаты отсутствуют.
- Неупорядоченность: у элементов множества нет порядкового номера. Нельзя получить доступ по индексу, как в списках.
- Изменяемость: можно добавлять во множество или удалять из него элементы.

Множества могут содержать только неизменяемые объекты:

- целые числа (integer),
- числа с плавающей точкой (float),
- строки (string),
- кортежи (tuple).

Тип данных **set** поддерживает математические операции над множествами (например, объединение, пересечение, разность).

Отличительной особенностью множеств являются фигурные скобки **{}**, но элементы не содержат ключей.

{1, 2, 2, 3, 4, 4, 5}

{'h','e','l','o'}



Создание множеств
``````````````````


** C помощью фигурных скобок**

.. code:: python

	my_set = {1, 2, 2, 3, 4, 4, 5}
	print(my_set) 

	{1, 2, 3, 4, 5}

.. important:: Использовать команду вида **my_set = {}** для создания множества нельзя, поскольку этой командой создается пустой словарь. set() - единственный вариант создания пустого множества.


**С помощью функции set()**

В качестве аргумента **set()** итерируемый объект (список, кортеж, строку или другой объект) — и возвращает множество его элементов. 


.. code:: python

	# создание пустого множества:
	my_set = set()
	print(my_set)
	
	set()
	
.. code:: python
	
	# создание множества из списка
	my_set = set([1, 2, 3, 4, 4, 5, 5])
	print(my_set)
	
	{1, 2, 3, 4, 5}

**Повторяющиеся элементы удаляются!!!**

.. code:: python
	
	# создание множества из списка

	my_string = "Hello, World!"
	my_set = set(my_string)
	print(my_set)
	# Результат: {'H', 'e', ' ', '!', 'o', 'r', 'l', ',', 'd', 'W'}
	
Каждый символ строки становится объектом множества. Повторяющиеся символы не добавляются.

.. code:: python

	#Создание множества из кортежа:
	my_tuple = (1, 2, 2, 3, 4, 5, 5)
	my_set = set(my_tuple)
	print(my_set)
	
	{1, 2, 3, 4, 5}
	
.. code:: python

	#Создание множества из диапазона (range):

	my_range = range(1, 6)
	my_set = set(my_range)
	print(my_set)
	# Результат: {1, 2, 3, 4, 5}


Кортежи (**tuple**) — это неизменяемый тип данных в Python, который используется для хранения упорядоченной последовательности элементов.

Кортежи представляют собой простые группы объектов. Они действуют точно так же, как списки, за исключением того, что не допускают непосредственного изменения (они являются неизменяемыми) и в литеральной форме записываются как последовательность элементов в **круглых**, а не в квадратных скобках.

Так как кортежей являются неизменяемыми коллекциями, то они обеспечивают поддержку целостности. Кортеж не будет изменен посредством другой ссылки из другого места в программе, чего нельзя сказать о списках. Существуют ситуации, в которых кортежи можно использовать, а списки – нет. Например, в качестве ключей словаря. Некоторые встроенные операции также могут требовать или предполагать использование кортежей, а не списков. 

.. important:: Списки должны выбираться, когда требуются упорядоченные коллекции, которые можно изменить. Кортежи могут использоваться в остальных случаях, когда необходимы фиксированные ассоциации объектов.

Кортеж поддерживают практически все операции над списками.

**Примеры кортежей**

.. code:: Python

        # Кортеж из строк
        fruits_tuple = ('яблоко', 'банан', 'апельсин')

        # Кортеж из логических значений
        my_tuple = (True, False, True)

        # Кортеж из других кортежей
        nested_tuple = ((1, 3), ('a', 'b'))

        # Кортеж из списков
        my_tuple = ([1, 2, 3], ['a', 'b', 'c'])

        # Кортеж из словарей
        my_tuple = ({'name': 'Mike', 'age': 18}, {'name': 'Anna', 'age': 21})

        # Кортеж из разных типов данных
        mixed_tuple = (1, 'hello', [1, 2, 3], {'a': 10})

Создание кортежей
``````````````````

- С помощью скобок:

fruits_tuple = ('яблоко', 'банан', 'апельсин')

- C помощью перечисления:

fruits_tuple = 'яблоко', 'банан', 'апельсин'

- Из итерируемого элемента с помощью функции tuple():

my_tuple_string = tuple('Jupyter')

my_tuple_list = tuple([1,2,3,4])

- Пустой кортеж:

empty_tuple = ()

Доступ к элементам
```````````````````````

Кортеж — это упорядоченная последовательность, поэтому для доступа к его элементам можно использовать индексы.

Индексация начинается с нуля. ПОследний индекс - значение, равное длине кортежа, уменьшенное на единицу.


.. code:: python

        fruits_tuple = ('яблоко', 'банан', 'апельсин')
        print(fruits_tuple[0])

        яблоко

Срезы
```````````````````````
.. code:: python

        fruits_tuple = ('яблоко', 'банан', 'апельсин', 'киви', 'абрикос')
        print(fruits_tuple[1:3])

        ('банан', 'апельсин')

Распаковка кортежа. 
````````````````````

Элементы кортежа извлекаются в переменные:

.. code:: python

	a, b, c, d = my_tuple
	# Теперь переменные a, b, c, d содержат значения из кортежа
	# a = 1, b = 2, c = 3, d = 'hello'

Обмен значениями между переменными
`````````````````````````````````````

.. code:: python

	x = 5
	y = 10
	# Обмен значениями с использованием кортежа, упаковки и распаковки
	x, y = y, x
	# x и y содержат новые значения
	print('x =', x) # Вывод: x = 10
	print('y =', y) # Вывод: y = 10
	
1. Операция упаковки (y, x)  создаёт кортеж из двух значений (10, 5), 
2. Операция распаковки (x, y) распаковывает кортеж и присваивает значения переменным x и y соответственно. Теперь переменная x = 10, а y = 5.

Конкатенация. 
``````````````

Это объединение двух кортежей в один новый кортеж с помощью оператора **+**

.. code:: python

	tup_1 = (1, 2, 3)
	tup_2 = (4, 5, 6)
	tup3 = tup_1 + tup_2
	print(f'Конкатенация кортежей {tup_3}')

	Конкатенация кортежей: (1, 2, 3, 4, 5, 6)

Преобразование в другие типы данных
````````````````````````````````````

**Преобразование кортежа в список**

.. code:: python
	
	my_tuple = (1, 2, 3, 4, 5)
	# Преобразование кортежа в список
	my_list = list(my_tuple)
	
	print('Кортеж:', my_tuple)
	print('Список:', my_list)
	
	Кортеж: (1, 2, 3, 4, 5)
	Список: [1, 2, 3, 4, 5]
	
	
**Преобразование кортежа в строку**

.. code:: python

	my_tuple = ('я','б','л','о','к','о')


	# Преобразование кортежа в строку
	my_string = ''.join(map(str, my_tuple))


	print('Кортеж:' my_tuple)
	print('Строка:', my_string)

	Кортеж: ('я','б','л','о','к','о')
	Строка: яблоко
	
	
Преобразование кортежа во множество
```````````````````````````````````

.. code:: python

	my_tuple = (1, 2, 3, 2, 4, 3, 4)



	# Преобразование кортежа во множество, при котором удаляются повторяющиеся элементы
	my_set = set(my_tuple)

	print('Кортеж:', my_tuple)
	print('Множество:', my_set)

	Кортеж: (1, 2, 3, 2, 4, 3, 4)
	Множество: {1, 2, 3, 4}

Множества — это неупорядоченные коллекции, которые состоят из уникальных элементов. 
В процессе преобразования последовательностей во множество все дубликаты в нём удаляются.

Создание замороженного множества (frozenset)
```````````````````````````````````````````````

frozenset() — это неизменяемый вариант множества, то есть добавить в него или удалить из него элементы не выйдет. Создать его можно так:

.. code:: python

	my_set = frozenset([1, 2, 3, 4, 5])
	print(my_set) 

	frozenset({1, 2, 3, 4, 5})

.. code:: python

	my_set.add(15)
	
	--------------------------------------------------------------------------
	AttributeError                            Traceback (most recent call last)
	Cell In[11], line 1
	----> 1 my_set.add(15)

	AttributeError: 'frozenset' object has no attribute 'add'


.. toctree::
   :maxdepth: 1
   :hidden:

   set_methods
   set_examples
	
